/**
 * Autogenerated by Thrift Compiler (0.19.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef webserver_TYPES_H
#define webserver_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>


namespace thrift { namespace webserver {

class ApiKey;

class ReadResult;

class MyException;


class ApiKey : public virtual ::apache::thrift::TBase {
 public:

  ApiKey(const ApiKey&);
  ApiKey& operator=(const ApiKey&);
  ApiKey() noexcept
         : orgName(),
           keyName() {
  }

  virtual ~ApiKey() noexcept;
  std::string orgName;
  std::string keyName;

  void __set_orgName(const std::string& val);

  void __set_keyName(const std::string& val);

  bool operator == (const ApiKey & rhs) const
  {
    if (!(orgName == rhs.orgName))
      return false;
    if (!(keyName == rhs.keyName))
      return false;
    return true;
  }
  bool operator != (const ApiKey &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ApiKey & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ApiKey &a, ApiKey &b);

std::ostream& operator<<(std::ostream& out, const ApiKey& obj);

typedef struct _ReadResult__isset {
  _ReadResult__isset() : res(false), cursor(false) {}
  bool res :1;
  bool cursor :1;
} _ReadResult__isset;

class ReadResult : public virtual ::apache::thrift::TBase {
 public:

  ReadResult(const ReadResult&);
  ReadResult& operator=(const ReadResult&);
  ReadResult() noexcept
             : returnCode(0),
               res(),
               cursor() {
  }

  virtual ~ReadResult() noexcept;
  int32_t returnCode;
  std::string res;
  std::string cursor;

  _ReadResult__isset __isset;

  void __set_returnCode(const int32_t val);

  void __set_res(const std::string& val);

  void __set_cursor(const std::string& val);

  bool operator == (const ReadResult & rhs) const
  {
    if (!(returnCode == rhs.returnCode))
      return false;
    if (__isset.res != rhs.__isset.res)
      return false;
    else if (__isset.res && !(res == rhs.res))
      return false;
    if (__isset.cursor != rhs.__isset.cursor)
      return false;
    else if (__isset.cursor && !(cursor == rhs.cursor))
      return false;
    return true;
  }
  bool operator != (const ReadResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReadResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ReadResult &a, ReadResult &b);

std::ostream& operator<<(std::ostream& out, const ReadResult& obj);

typedef struct _MyException__isset {
  _MyException__isset() : errorCode(false), errorMessage(false) {}
  bool errorCode :1;
  bool errorMessage :1;
} _MyException__isset;

class MyException : public ::apache::thrift::TException {
 public:

  MyException(const MyException&);
  MyException& operator=(const MyException&);
  MyException() noexcept
              : errorCode(0),
                errorMessage() {
  }

  virtual ~MyException() noexcept;
  int32_t errorCode;
  std::string errorMessage;

  _MyException__isset __isset;

  void __set_errorCode(const int32_t val);

  void __set_errorMessage(const std::string& val);

  bool operator == (const MyException & rhs) const
  {
    if (!(errorCode == rhs.errorCode))
      return false;
    if (!(errorMessage == rhs.errorMessage))
      return false;
    return true;
  }
  bool operator != (const MyException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MyException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(MyException &a, MyException &b);

std::ostream& operator<<(std::ostream& out, const MyException& obj);

}} // namespace

#endif
